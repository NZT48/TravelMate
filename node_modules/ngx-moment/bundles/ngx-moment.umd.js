(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('moment')) :
    typeof define === 'function' && define.amd ? define('ngx-moment', ['exports', '@angular/core', 'moment'], factory) :
    (global = global || self, factory(global['ngx-moment'] = {}, global.ng.core, global.moment));
}(this, (function (exports, core, moment) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var momentConstructor = moment;
    var AddPipe = /** @class */ (function () {
        function AddPipe() {
        }
        AddPipe.prototype.transform = function (value, amount, unit) {
            if (typeof amount === 'undefined' ||
                (typeof amount === 'number' && typeof unit === 'undefined')) {
                throw new Error('AddPipe: missing required arguments');
            }
            return momentConstructor(value).add(amount, unit);
        };
        AddPipe = __decorate([
            core.Pipe({ name: 'amAdd' })
        ], AddPipe);
        return AddPipe;
    }());

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var momentConstructor$1 = moment;
    var CalendarPipe = /** @class */ (function () {
        function CalendarPipe(cdRef, ngZone) {
            var _this = this;
            this.cdRef = cdRef;
            this.ngZone = ngZone;
            // using a single static timer for all instances of this pipe for performance reasons
            CalendarPipe_1.initTimer(ngZone);
            CalendarPipe_1.refs++;
            // values such as Today will need to be replaced with Yesterday after midnight,
            // so make sure we subscribe to an EventEmitter that we set up to emit at midnight
            this.midnightSub = CalendarPipe_1.midnight.subscribe(function () {
                _this.ngZone.run(function () { return _this.cdRef.markForCheck(); });
            });
        }
        CalendarPipe_1 = CalendarPipe;
        CalendarPipe.prototype.transform = function (value) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var formats = null;
            var referenceTime = null;
            for (var i = 0, len = args.length; i < len; i++) {
                if (args[i] !== null) {
                    if (typeof args[i] === 'object' && !moment.isMoment(args[i])) {
                        formats = args[i];
                    }
                    else {
                        referenceTime = momentConstructor$1(args[i]);
                    }
                }
            }
            return momentConstructor$1(value).calendar(referenceTime, formats);
        };
        CalendarPipe.prototype.ngOnDestroy = function () {
            if (CalendarPipe_1.refs > 0) {
                CalendarPipe_1.refs--;
            }
            if (CalendarPipe_1.refs === 0) {
                CalendarPipe_1.removeTimer();
            }
            this.midnightSub.unsubscribe();
        };
        CalendarPipe.initTimer = function (ngZone) {
            // initialize the timer
            if (!CalendarPipe_1.midnight) {
                CalendarPipe_1.midnight = new core.EventEmitter();
                if (typeof window !== 'undefined') {
                    var timeToUpdate_1 = CalendarPipe_1._getMillisecondsUntilUpdate();
                    CalendarPipe_1.timer = ngZone.runOutsideAngular(function () {
                        return window.setTimeout(function () {
                            // emit the current date
                            CalendarPipe_1.midnight.emit(new Date());
                            // refresh the timer
                            CalendarPipe_1.removeTimer();
                            CalendarPipe_1.initTimer(ngZone);
                        }, timeToUpdate_1);
                    });
                }
            }
        };
        CalendarPipe.removeTimer = function () {
            if (CalendarPipe_1.timer) {
                window.clearTimeout(CalendarPipe_1.timer);
                CalendarPipe_1.timer = null;
                CalendarPipe_1.midnight = null;
            }
        };
        CalendarPipe._getMillisecondsUntilUpdate = function () {
            var now = momentConstructor$1();
            var tomorrow = momentConstructor$1().startOf('day').add(1, 'days');
            var timeToMidnight = tomorrow.valueOf() - now.valueOf();
            return timeToMidnight + 1000; // 1 second after midnight
        };
        var CalendarPipe_1;
        /**
         * Internal reference counter, so we can clean up when no instances are in use
         */
        CalendarPipe.refs = 0;
        CalendarPipe.timer = null;
        CalendarPipe.midnight = null;
        CalendarPipe.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.NgZone }
        ]; };
        CalendarPipe = CalendarPipe_1 = __decorate([
            core.Pipe({ name: 'amCalendar', pure: false })
        ], CalendarPipe);
        return CalendarPipe;
    }());

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var momentConstructor$2 = moment;
    var DateFormatPipe = /** @class */ (function () {
        function DateFormatPipe() {
        }
        DateFormatPipe.prototype.transform = function (value) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (!value) {
                return '';
            }
            return momentConstructor$2(value).format(args[0]);
        };
        DateFormatPipe = __decorate([
            core.Pipe({ name: 'amDateFormat' })
        ], DateFormatPipe);
        return DateFormatPipe;
    }());

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var momentConstructor$3 = moment;
    var DifferencePipe = /** @class */ (function () {
        function DifferencePipe() {
        }
        DifferencePipe.prototype.transform = function (value, otherValue, unit, precision) {
            var date = momentConstructor$3(value);
            var date2 = otherValue !== null ? momentConstructor$3(otherValue) : momentConstructor$3();
            return date.diff(date2, unit, precision);
        };
        DifferencePipe = __decorate([
            core.Pipe({ name: 'amDifference' })
        ], DifferencePipe);
        return DifferencePipe;
    }());

    var NGX_MOMENT_OPTIONS = new core.InjectionToken('NGX_MOMENT_OPTIONS');

    var DurationPipe = /** @class */ (function () {
        function DurationPipe(momentOptions) {
            this.allowedUnits = ['ss', 's', 'm', 'h', 'd', 'M'];
            this._applyOptions(momentOptions);
        }
        DurationPipe.prototype.transform = function (value) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (typeof args === 'undefined' || args.length !== 1) {
                throw new Error('DurationPipe: missing required time unit argument');
            }
            return moment.duration(value, args[0]).humanize();
        };
        DurationPipe.prototype._applyOptions = function (momentOptions) {
            var _this = this;
            if (!momentOptions) {
                return;
            }
            if (!!momentOptions.relativeTimeThresholdOptions) {
                var units = Object.keys(momentOptions.relativeTimeThresholdOptions);
                var filteredUnits = units.filter(function (unit) { return _this.allowedUnits.indexOf(unit) !== -1; });
                filteredUnits.forEach(function (unit) {
                    moment.relativeTimeThreshold(unit, momentOptions.relativeTimeThresholdOptions[unit]);
                });
            }
        };
        DurationPipe.ctorParameters = function () { return [
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [NGX_MOMENT_OPTIONS,] }] }
        ]; };
        DurationPipe = __decorate([
            core.Pipe({ name: 'amDuration' }),
            __param(0, core.Optional()), __param(0, core.Inject(NGX_MOMENT_OPTIONS))
        ], DurationPipe);
        return DurationPipe;
    }());

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var FromUnixPipe = /** @class */ (function () {
        function FromUnixPipe() {
        }
        FromUnixPipe.prototype.transform = function (value) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return typeof value === 'string' ? moment.unix(parseInt(value, 10)) : moment.unix(value);
        };
        FromUnixPipe = __decorate([
            core.Pipe({ name: 'amFromUnix' })
        ], FromUnixPipe);
        return FromUnixPipe;
    }());

    var momentConstructor$4 = moment;
    var ParsePipe = /** @class */ (function () {
        function ParsePipe() {
        }
        ParsePipe.prototype.transform = function (value, formats) {
            return momentConstructor$4(value, formats);
        };
        ParsePipe = __decorate([
            core.Pipe({ name: 'amParse' })
        ], ParsePipe);
        return ParsePipe;
    }());

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var FromUtcPipe = /** @class */ (function () {
        function FromUtcPipe() {
        }
        FromUtcPipe.prototype.transform = function (value, formats) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            return formats ? moment.utc(value, formats) : moment.utc(value);
        };
        FromUtcPipe = __decorate([
            core.Pipe({ name: 'amFromUtc' })
        ], FromUtcPipe);
        return FromUtcPipe;
    }());

    var momentConstructor$5 = moment;
    var IsAfterPipe = /** @class */ (function () {
        function IsAfterPipe() {
        }
        IsAfterPipe.prototype.transform = function (value, otherValue, unit) {
            return momentConstructor$5(value).isAfter(momentConstructor$5(otherValue), unit);
        };
        IsAfterPipe = __decorate([
            core.Pipe({
                name: 'amIsAfter',
            })
        ], IsAfterPipe);
        return IsAfterPipe;
    }());

    var momentConstructor$6 = moment;
    var IsBeforePipe = /** @class */ (function () {
        function IsBeforePipe() {
        }
        IsBeforePipe.prototype.transform = function (value, otherValue, unit) {
            return momentConstructor$6(value).isBefore(momentConstructor$6(otherValue), unit);
        };
        IsBeforePipe = __decorate([
            core.Pipe({
                name: 'amIsBefore',
            })
        ], IsBeforePipe);
        return IsBeforePipe;
    }());

    var momentConstructor$7 = moment;
    var LocalTimePipe = /** @class */ (function () {
        function LocalTimePipe() {
        }
        LocalTimePipe.prototype.transform = function (value) {
            return momentConstructor$7(value).local();
        };
        LocalTimePipe = __decorate([
            core.Pipe({ name: 'amLocal' })
        ], LocalTimePipe);
        return LocalTimePipe;
    }());

    // See https://github.com/ng-packagr/ng-packagr/issues/217 for why this is needed:
    var momentConstructor$8 = moment;
    var LocalePipe = /** @class */ (function () {
        function LocalePipe() {
        }
        LocalePipe.prototype.transform = function (value, locale) {
            return momentConstructor$8(value).locale(locale);
        };
        LocalePipe = __decorate([
            core.Pipe({ name: 'amLocale' })
        ], LocalePipe);
        return LocalePipe;
    }());

    var ParseZonePipe = /** @class */ (function () {
        function ParseZonePipe() {
        }
        ParseZonePipe.prototype.transform = function (value) {
            return moment.parseZone(value);
        };
        ParseZonePipe = __decorate([
            core.Pipe({ name: 'amParseZone' })
        ], ParseZonePipe);
        return ParseZonePipe;
    }());

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var momentConstructor$9 = moment;
    var SubtractPipe = /** @class */ (function () {
        function SubtractPipe() {
        }
        SubtractPipe.prototype.transform = function (value, amount, unit) {
            if (typeof amount === 'undefined' ||
                (typeof amount === 'number' && typeof unit === 'undefined')) {
                throw new Error('SubtractPipe: missing required arguments');
            }
            return momentConstructor$9(value).subtract(amount, unit);
        };
        SubtractPipe = __decorate([
            core.Pipe({ name: 'amSubtract' })
        ], SubtractPipe);
        return SubtractPipe;
    }());

    /* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
    var momentConstructor$a = moment;
    var TimeAgoPipe = /** @class */ (function () {
        function TimeAgoPipe(cdRef, ngZone) {
            this.cdRef = cdRef;
            this.ngZone = ngZone;
        }
        TimeAgoPipe.prototype.format = function (m) {
            return m.from(momentConstructor$a(), this.lastOmitSuffix);
        };
        TimeAgoPipe.prototype.transform = function (value, omitSuffix, formatFn) {
            if (this.hasChanged(value, omitSuffix)) {
                this.lastTime = this.getTime(value);
                this.lastValue = value;
                this.lastOmitSuffix = omitSuffix;
                this.lastLocale = this.getLocale(value);
                this.formatFn = formatFn || this.format.bind(this);
                this.removeTimer();
                this.createTimer();
                this.lastText = this.formatFn(momentConstructor$a(value));
            }
            else {
                this.createTimer();
            }
            return this.lastText;
        };
        TimeAgoPipe.prototype.ngOnDestroy = function () {
            this.removeTimer();
        };
        TimeAgoPipe.prototype.createTimer = function () {
            var _this = this;
            if (this.currentTimer) {
                return;
            }
            var momentInstance = momentConstructor$a(this.lastValue);
            var timeToUpdate = this.getSecondsUntilUpdate(momentInstance) * 1000;
            this.currentTimer = this.ngZone.runOutsideAngular(function () {
                if (typeof window !== 'undefined') {
                    return window.setTimeout(function () {
                        _this.lastText = _this.formatFn(momentConstructor$a(_this.lastValue));
                        _this.currentTimer = null;
                        _this.ngZone.run(function () { return _this.cdRef.markForCheck(); });
                    }, timeToUpdate);
                }
                else {
                    return null;
                }
            });
        };
        TimeAgoPipe.prototype.removeTimer = function () {
            if (this.currentTimer) {
                window.clearTimeout(this.currentTimer);
                this.currentTimer = null;
            }
        };
        TimeAgoPipe.prototype.getSecondsUntilUpdate = function (momentInstance) {
            var howOld = Math.abs(momentConstructor$a().diff(momentInstance, 'minute'));
            if (howOld < 1) {
                return 1;
            }
            else if (howOld < 60) {
                return 30;
            }
            else if (howOld < 180) {
                return 300;
            }
            else {
                return 3600;
            }
        };
        TimeAgoPipe.prototype.hasChanged = function (value, omitSuffix) {
            return (this.getTime(value) !== this.lastTime ||
                this.getLocale(value) !== this.lastLocale ||
                omitSuffix !== this.lastOmitSuffix);
        };
        TimeAgoPipe.prototype.getTime = function (value) {
            if (moment.isDate(value)) {
                return value.getTime();
            }
            else if (moment.isMoment(value)) {
                return value.valueOf();
            }
            else {
                return momentConstructor$a(value).valueOf();
            }
        };
        TimeAgoPipe.prototype.getLocale = function (value) {
            return moment.isMoment(value) ? value.locale() : moment.locale();
        };
        TimeAgoPipe.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.NgZone }
        ]; };
        TimeAgoPipe = __decorate([
            core.Pipe({ name: 'amTimeAgo', pure: false })
        ], TimeAgoPipe);
        return TimeAgoPipe;
    }());

    var momentConstructor$b = moment;
    var UtcPipe = /** @class */ (function () {
        function UtcPipe() {
        }
        UtcPipe.prototype.transform = function (value) {
            return momentConstructor$b(value).utc();
        };
        UtcPipe = __decorate([
            core.Pipe({ name: 'amUtc' })
        ], UtcPipe);
        return UtcPipe;
    }());

    var ANGULAR_MOMENT_PIPES = [
        AddPipe,
        CalendarPipe,
        DateFormatPipe,
        DifferencePipe,
        DurationPipe,
        FromUnixPipe,
        ParsePipe,
        SubtractPipe,
        TimeAgoPipe,
        UtcPipe,
        FromUtcPipe,
        LocalTimePipe,
        LocalePipe,
        ParseZonePipe,
        IsBeforePipe,
        IsAfterPipe,
    ];
    var MomentModule = /** @class */ (function () {
        function MomentModule() {
        }
        MomentModule_1 = MomentModule;
        MomentModule.forRoot = function (options) {
            return {
                ngModule: MomentModule_1,
                providers: [
                    {
                        provide: NGX_MOMENT_OPTIONS,
                        useValue: __assign({}, options),
                    },
                ],
            };
        };
        var MomentModule_1;
        MomentModule = MomentModule_1 = __decorate([
            core.NgModule({
                declarations: ANGULAR_MOMENT_PIPES,
                exports: ANGULAR_MOMENT_PIPES,
            })
        ], MomentModule);
        return MomentModule;
    }());

    exports.AddPipe = AddPipe;
    exports.CalendarPipe = CalendarPipe;
    exports.DateFormatPipe = DateFormatPipe;
    exports.DifferencePipe = DifferencePipe;
    exports.DurationPipe = DurationPipe;
    exports.FromUnixPipe = FromUnixPipe;
    exports.FromUtcPipe = FromUtcPipe;
    exports.IsAfterPipe = IsAfterPipe;
    exports.IsBeforePipe = IsBeforePipe;
    exports.LocalTimePipe = LocalTimePipe;
    exports.LocalePipe = LocalePipe;
    exports.MomentModule = MomentModule;
    exports.NGX_MOMENT_OPTIONS = NGX_MOMENT_OPTIONS;
    exports.ParsePipe = ParsePipe;
    exports.ParseZonePipe = ParseZonePipe;
    exports.SubtractPipe = SubtractPipe;
    exports.TimeAgoPipe = TimeAgoPipe;
    exports.UtcPipe = UtcPipe;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-moment.umd.js.map
