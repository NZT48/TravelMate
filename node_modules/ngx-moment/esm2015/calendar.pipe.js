/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
var CalendarPipe_1;
import { __decorate } from "tslib";
import { Pipe, ChangeDetectorRef, PipeTransform, EventEmitter, OnDestroy, NgZone, } from '@angular/core';
import * as moment from 'moment';
const momentConstructor = moment;
let CalendarPipe = CalendarPipe_1 = class CalendarPipe {
    constructor(cdRef, ngZone) {
        this.cdRef = cdRef;
        this.ngZone = ngZone;
        // using a single static timer for all instances of this pipe for performance reasons
        CalendarPipe_1.initTimer(ngZone);
        CalendarPipe_1.refs++;
        // values such as Today will need to be replaced with Yesterday after midnight,
        // so make sure we subscribe to an EventEmitter that we set up to emit at midnight
        this.midnightSub = CalendarPipe_1.midnight.subscribe(() => {
            this.ngZone.run(() => this.cdRef.markForCheck());
        });
    }
    transform(value, ...args) {
        let formats = null;
        let referenceTime = null;
        for (let i = 0, len = args.length; i < len; i++) {
            if (args[i] !== null) {
                if (typeof args[i] === 'object' && !moment.isMoment(args[i])) {
                    formats = args[i];
                }
                else {
                    referenceTime = momentConstructor(args[i]);
                }
            }
        }
        return momentConstructor(value).calendar(referenceTime, formats);
    }
    ngOnDestroy() {
        if (CalendarPipe_1.refs > 0) {
            CalendarPipe_1.refs--;
        }
        if (CalendarPipe_1.refs === 0) {
            CalendarPipe_1.removeTimer();
        }
        this.midnightSub.unsubscribe();
    }
    static initTimer(ngZone) {
        // initialize the timer
        if (!CalendarPipe_1.midnight) {
            CalendarPipe_1.midnight = new EventEmitter();
            if (typeof window !== 'undefined') {
                const timeToUpdate = CalendarPipe_1._getMillisecondsUntilUpdate();
                CalendarPipe_1.timer = ngZone.runOutsideAngular(() => {
                    return window.setTimeout(() => {
                        // emit the current date
                        CalendarPipe_1.midnight.emit(new Date());
                        // refresh the timer
                        CalendarPipe_1.removeTimer();
                        CalendarPipe_1.initTimer(ngZone);
                    }, timeToUpdate);
                });
            }
        }
    }
    static removeTimer() {
        if (CalendarPipe_1.timer) {
            window.clearTimeout(CalendarPipe_1.timer);
            CalendarPipe_1.timer = null;
            CalendarPipe_1.midnight = null;
        }
    }
    static _getMillisecondsUntilUpdate() {
        const now = momentConstructor();
        const tomorrow = momentConstructor().startOf('day').add(1, 'days');
        const timeToMidnight = tomorrow.valueOf() - now.valueOf();
        return timeToMidnight + 1000; // 1 second after midnight
    }
};
/**
 * Internal reference counter, so we can clean up when no instances are in use
 */
CalendarPipe.refs = 0;
CalendarPipe.timer = null;
CalendarPipe.midnight = null;
CalendarPipe.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone }
];
CalendarPipe = CalendarPipe_1 = __decorate([
    Pipe({ name: 'amCalendar', pure: false })
], CalendarPipe);
export { CalendarPipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1tb21lbnQvIiwic291cmNlcyI6WyJjYWxlbmRhci5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHdEQUF3RDs7O0FBRXhELE9BQU8sRUFDTCxJQUFJLEVBQ0osaUJBQWlCLEVBQ2pCLGFBQWEsRUFDYixZQUFZLEVBQ1osU0FBUyxFQUNULE1BQU0sR0FDUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEtBQUssTUFBTSxNQUFNLFFBQVEsQ0FBQztBQUdqQyxNQUFNLGlCQUFpQixHQUFHLE1BQU0sQ0FBQztBQUdqQyxJQUFhLFlBQVksb0JBQXpCLE1BQWEsWUFBWTtJQVd2QixZQUFvQixLQUF3QixFQUFVLE1BQWM7UUFBaEQsVUFBSyxHQUFMLEtBQUssQ0FBbUI7UUFBVSxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ2xFLHFGQUFxRjtRQUNyRixjQUFZLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRS9CLGNBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUVwQiwrRUFBK0U7UUFDL0Usa0ZBQWtGO1FBQ2xGLElBQUksQ0FBQyxXQUFXLEdBQUcsY0FBWSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO1lBQ3RELElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztRQUNuRCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxTQUFTLENBQUMsS0FBeUIsRUFBRSxHQUFHLElBQVc7UUFDakQsSUFBSSxPQUFPLEdBQVEsSUFBSSxDQUFDO1FBQ3hCLElBQUksYUFBYSxHQUFRLElBQUksQ0FBQztRQUU5QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENB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SSxFQUFFLEtBQUssRUFBRSxDQUFDO0dBQzdCLFlBQVksQ0F1RnhCO1NBdkZZLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBuZ3gtbW9tZW50IChjKSAyMDE1LCAyMDE2IFVyaSBTaGFrZWQgLyBNSVQgTGljZW5jZSAqL1xuXG5pbXBvcnQge1xuICBQaXBlLFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgUGlwZVRyYW5zZm9ybSxcbiAgRXZlbnRFbWl0dGVyLFxuICBPbkRlc3Ryb3ksXG4gIE5nWm9uZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSAnbW9tZW50JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5jb25zdCBtb21lbnRDb25zdHJ1Y3RvciA9IG1vbWVudDtcblxuQFBpcGUoeyBuYW1lOiAnYW1DYWxlbmRhcicsIHB1cmU6IGZhbHNlIH0pXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSwgT25EZXN0cm95IHtcbiAgLyoqXG4gICAqIEludGVybmFsIHJlZmVyZW5jZSBjb3VudGVyLCBzbyB3ZSBjYW4gY2xlYW4gdXAgd2hlbiBubyBpbnN0YW5jZXMgYXJlIGluIHVzZVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgcmVmcyA9IDA7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgdGltZXI6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHN0YXRpYyBtaWRuaWdodDogRXZlbnRFbWl0dGVyPERhdGU+IHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBtaWRuaWdodFN1YjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY2RSZWY6IENoYW5nZURldGVjdG9yUmVmLCBwcml2YXRlIG5nWm9uZTogTmdab25lKSB7XG4gICAgLy8gdXNpbmcgYSBzaW5nbGUgc3RhdGljIHRpbWVyIGZvciBhbGwgaW5zdGFuY2VzIG9mIHRoaXMgcGlwZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICAgIENhbGVuZGFyUGlwZS5pbml0VGltZXIobmdab25lKTtcblxuICAgIENhbGVuZGFyUGlwZS5yZWZzKys7XG5cbiAgICAvLyB2YWx1ZXMgc3VjaCBhcyBUb2RheSB3aWxsIG5lZWQgdG8gYmUgcmVwbGFjZWQgd2l0aCBZZXN0ZXJkYXkgYWZ0ZXIgbWlkbmlnaHQsXG4gICAgLy8gc28gbWFrZSBzdXJlIHdlIHN1YnNjcmliZSB0byBhbiBFdmVudEVtaXR0ZXIgdGhhdCB3ZSBzZXQgdXAgdG8gZW1pdCBhdCBtaWRuaWdodFxuICAgIHRoaXMubWlkbmlnaHRTdWIgPSBDYWxlbmRhclBpcGUubWlkbmlnaHQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB0aGlzLmNkUmVmLm1hcmtGb3JDaGVjaygpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHRyYW5zZm9ybSh2YWx1ZTogbW9tZW50Lk1vbWVudElucHV0LCAuLi5hcmdzOiBhbnlbXSk6IGFueSB7XG4gICAgbGV0IGZvcm1hdHM6IGFueSA9IG51bGw7XG4gICAgbGV0IHJlZmVyZW5jZVRpbWU6IGFueSA9IG51bGw7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGFyZ3NbaV0gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2ldID09PSAnb2JqZWN0JyAmJiAhbW9tZW50LmlzTW9tZW50KGFyZ3NbaV0pKSB7XG4gICAgICAgICAgZm9ybWF0cyA9IGFyZ3NbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmZXJlbmNlVGltZSA9IG1vbWVudENvbnN0cnVjdG9yKGFyZ3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vbWVudENvbnN0cnVjdG9yKHZhbHVlKS5jYWxlbmRhcihyZWZlcmVuY2VUaW1lLCBmb3JtYXRzKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIGlmIChDYWxlbmRhclBpcGUucmVmcyA+IDApIHtcbiAgICAgIENhbGVuZGFyUGlwZS5yZWZzLS07XG4gICAgfVxuXG4gICAgaWYgKENhbGVuZGFyUGlwZS5yZWZzID09PSAwKSB7XG4gICAgICBDYWxlbmRhclBpcGUucmVtb3ZlVGltZXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLm1pZG5pZ2h0U3ViLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBpbml0VGltZXIobmdab25lOiBOZ1pvbmUpIHtcbiAgICAvLyBpbml0aWFsaXplIHRoZSB0aW1lclxuICAgIGlmICghQ2FsZW5kYXJQaXBlLm1pZG5pZ2h0KSB7XG4gICAgICBDYWxlbmRhclBpcGUubWlkbmlnaHQgPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgdGltZVRvVXBkYXRlID0gQ2FsZW5kYXJQaXBlLl9nZXRNaWxsaXNlY29uZHNVbnRpbFVwZGF0ZSgpO1xuICAgICAgICBDYWxlbmRhclBpcGUudGltZXIgPSBuZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBlbWl0IHRoZSBjdXJyZW50IGRhdGVcbiAgICAgICAgICAgIENhbGVuZGFyUGlwZS5taWRuaWdodC5lbWl0KG5ldyBEYXRlKCkpO1xuXG4gICAgICAgICAgICAvLyByZWZyZXNoIHRoZSB0aW1lclxuICAgICAgICAgICAgQ2FsZW5kYXJQaXBlLnJlbW92ZVRpbWVyKCk7XG4gICAgICAgICAgICBDYWxlbmRhclBpcGUuaW5pdFRpbWVyKG5nWm9uZSk7XG4gICAgICAgICAgfSwgdGltZVRvVXBkYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcmVtb3ZlVGltZXIoKSB7XG4gICAgaWYgKENhbGVuZGFyUGlwZS50aW1lcikge1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dChDYWxlbmRhclBpcGUudGltZXIpO1xuICAgICAgQ2FsZW5kYXJQaXBlLnRpbWVyID0gbnVsbDtcbiAgICAgIENhbGVuZGFyUGlwZS5taWRuaWdodCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX2dldE1pbGxpc2Vjb25kc1VudGlsVXBkYXRlKCkge1xuICAgIGNvbnN0IG5vdyA9IG1vbWVudENvbnN0cnVjdG9yKCk7XG4gICAgY29uc3QgdG9tb3Jyb3cgPSBtb21lbnRDb25zdHJ1Y3RvcigpLnN0YXJ0T2YoJ2RheScpLmFkZCgxLCAnZGF5cycpO1xuICAgIGNvbnN0IHRpbWVUb01pZG5pZ2h0ID0gdG9tb3Jyb3cudmFsdWVPZigpIC0gbm93LnZhbHVlT2YoKTtcbiAgICByZXR1cm4gdGltZVRvTWlkbmlnaHQgKyAxMDAwOyAvLyAxIHNlY29uZCBhZnRlciBtaWRuaWdodFxuICB9XG59XG4iXX0=